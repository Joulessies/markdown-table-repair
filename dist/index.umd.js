(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.markdownTableRepair = {}));
})(this, (function (exports) { 'use strict';

  /**
   * markdown-table-repair
   * A zero-dependency utility that fixes broken Markdown tables generated by AI LLMs.
   */

  /**
   * Repairs broken Markdown tables in the provided string.
   * Handles missing pipes, mismatched columns, incomplete separator rows,
   * and partial tables from streaming AI responses.
   *
   * @param {string} input - The Markdown string containing potentially broken tables.
   * @returns {string} - The Markdown string with all tables repaired.
   */
  function repairTable(input) {
    if (typeof input !== 'string') {
      return '';
    }

    if (!input.includes('|')) {
      return input;
    }

    const lines = input.split('\n');
    const result = [];
    let tableLines = [];
    let inTable = false;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const trimmed = line.trim();

      // Check if this line is part of a table
      const isTableLine = trimmed.includes('|') || 
        (inTable && trimmed.length > 0 && !trimmed.startsWith('#'));

      if (isTableLine && trimmed.includes('|')) {
        inTable = true;
        tableLines.push(line);
      } else if (inTable && trimmed === '') {
        // Empty line ends the table
        if (tableLines.length > 0) {
          result.push(...repairTableBlock(tableLines));
          tableLines = [];
        }
        inTable = false;
        result.push(line);
      } else {
        // Non-table line
        if (tableLines.length > 0) {
          result.push(...repairTableBlock(tableLines));
          tableLines = [];
        }
        inTable = false;
        result.push(line);
      }
    }

    // Handle any remaining table lines
    if (tableLines.length > 0) {
      result.push(...repairTableBlock(tableLines));
    }

    return result.join('\n');
  }

  /**
   * Repairs a block of table lines.
   * @param {string[]} lines - Array of table row strings.
   * @returns {string[]} - Array of repaired table row strings.
   */
  function repairTableBlock(lines) {
    if (lines.length === 0) return lines;

    // Parse each line to extract cells
    const parsedRows = lines.map((line) => parseTableRow(line));

    // Determine the maximum column count
    const maxColumns = Math.max(...parsedRows.map((row) => row.cells.length), 1);

    // Check if we have a separator row
    let separatorIndex = -1;
    for (let i = 0; i < parsedRows.length; i++) {
      if (isSeparatorRow(parsedRows[i].cells)) {
        separatorIndex = i;
        break;
      }
    }

    // If no separator and we have at least a header, insert one
    if (separatorIndex === -1 && parsedRows.length >= 1) {
      // Insert separator after first row
      const separatorCells = Array(maxColumns).fill('---');
      parsedRows.splice(1, 0, { cells: separatorCells, leadingWhitespace: parsedRows[0].leadingWhitespace });
    }

    // Normalize all rows to have the same number of columns
    const repairedLines = parsedRows.map((row) => {
      const cells = [...row.cells];

      // Pad with empty cells if needed
      while (cells.length < maxColumns) {
        cells.push(isSeparatorRow(cells) ? '---' : '');
      }

      // Trim excess cells
      if (cells.length > maxColumns) {
        cells.length = maxColumns;
      }

      // Reconstruct the row with proper formatting
      return row.leadingWhitespace + '| ' + cells.join(' | ') + ' |';
    });

    return repairedLines;
  }

  /**
   * Parses a table row string into cells.
   * @param {string} line - A table row string.
   * @returns {{ cells: string[], leadingWhitespace: string }}
   */
  function parseTableRow(line) {
    // Capture leading whitespace
    const leadingMatch = line.match(/^(\s*)/);
    const leadingWhitespace = leadingMatch ? leadingMatch[1] : '';

    let content = line.trim();

    // Remove leading pipe if present
    if (content.startsWith('|')) {
      content = content.slice(1);
    }

    // Remove trailing pipe if present
    if (content.endsWith('|')) {
      content = content.slice(0, -1);
    }

    // Split by pipe and trim each cell
    const cells = content.split('|').map((cell) => cell.trim());

    // Filter out completely empty results from malformed input
    if (cells.length === 1 && cells[0] === '') {
      return { cells: [], leadingWhitespace };
    }

    return { cells, leadingWhitespace };
  }

  /**
   * Checks if the cells represent a separator row.
   * @param {string[]} cells - Array of cell contents.
   * @returns {boolean}
   */
  function isSeparatorRow(cells) {
    if (cells.length === 0) return false;

    return cells.every((cell) => {
      const cleaned = cell.replace(/:/g, '').trim();
      return /^-+$/.test(cleaned) || cleaned === '';
    });
  }

  exports.default = repairTable;
  exports.repairTable = repairTable;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
